================================================================================
                    HOW C/C++ FFI WORKS WITH RUST
================================================================================


1. SOURCE FILES
===============

    crates/hl_ffi/src/lib.rs          include/hyprlog.h
    ========================          =================

    #[no_mangle]                      // Auto-generated by cbindgen
    pub extern "C" fn                 struct HyprlogContext;
      hyprlog_init() -> *mut ...      HyprlogContext* hyprlog_init(void);
                |                                |
                |                                |
                v                                v
         ACTUAL CODE                      JUST DECLARATIONS
         (implementation)                 (no code, just signatures)


2. BUILD PROCESS
================

    RUST SIDE                              C++ SIDE
    =========                              ========

    cargo build --release                  cmake && make
          |                                      |
          v                                      v
    libhyprlog.so                           main.cpp + hyprlog.h
    (machine code)                         (compiled to main.o)
          |                                      |
          |                                      |
          +----------------+  +------------------+
                           |  |
                           v  v
                      LINKER combines:
                      - main.o (your code)
                      - libhyprlog.so (Rust code)
                              |
                              v
                      hyprlog_example
                      (final executable)


3. WHAT'S IN EACH FILE
======================

    hyprlog.h (Header)                 libhyprlog.so (Library)
    ==================                 ======================

    "These functions exist:"           Actual machine code:

    HyprlogContext* hyprlog_init();    hyprlog_init:
        ^                                  push rbp
        |                                  mov rbp, rsp
        |                                  call Logger::builder
    Just a PROMISE                         call Box::into_raw
    No actual code!                        pop rbp
                                           ret


4. RUNTIME FLOW
===============

    Your C++ code                    What actually happens
    =============                    =====================

    ctx = hyprlog_init();     --->   1. CPU jumps to hyprlog_init in libhyprlog.so
                                     2. Rust code executes:
                                        - Logger::builder().build()
                                        - Box::new(HyprlogContext { ... })
                                        - Box::into_raw(ctx)
                                     3. Returns pointer to C++

    hyprlog_info(ctx, ...)    --->   1. CPU jumps to hyprlog_info in libhyprlog.so
                                     2. Rust code:
                                        - Converts C strings to &str
                                        - Calls context.logger.log(...)
                                        - Prints to terminal

    hyprlog_free(ctx);        --->   1. CPU jumps to hyprlog_free in libhyprlog.so
                                     2. Rust code:
                                        - Box::from_raw(ctx)  // take ownership
                                        - drop()              // free memory


5. MEMORY OWNERSHIP
===================

    C++ sees:                        Rust manages:
    =========                        ==============

    HyprlogContext* ctx;             Box<HyprlogContext>
         |                                   |
         |  (raw pointer)                    |  (owned heap allocation)
         |                                   |
         v                                   v
    +----+----+                        +-----+-----+
    | 0x7fff  |  ----points to---->    | Logger    |
    +---------+                        | RefCell   |
                                       +-----------+

    C++ has NO IDEA about:           Rust handles:
    - How big the struct is          - Allocation
    - What's inside it               - Deallocation
    - When to free it                - Thread safety

    YOU MUST call hyprlog_free()!
    Otherwise: MEMORY LEAK


6. WHY extern "C"?
==================

    Rust normally "mangles" function names:

        fn hyprlog_init() -> ...
              |
              v
        _ZN7hl_ffi12hyprlog_init17h8a3b2c1d0e9f8a7bE  (mangled)

    With #[no_mangle] + extern "C":

        #[no_mangle]
        pub extern "C" fn hyprlog_init() -> ...
              |
              v
        hyprlog_init  (clean, C-compatible name)

    This lets C/C++ find the function!


7. THE KEY INSIGHT
==================

    +------------------------------------------------------------------+
    |                                                                  |
    |   The .h header is just a CONTRACT                               |
    |                                                                  |
    |   It says: "I promise these functions exist somewhere"           |
    |                                                                  |
    |   The .so library FULFILLS that contract                         |
    |                                                                  |
    |   The LINKER connects them                                       |
    |                                                                  |
    +------------------------------------------------------------------+

================================================================================
